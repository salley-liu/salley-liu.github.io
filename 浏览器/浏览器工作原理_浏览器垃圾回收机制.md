# Chrome JavaScript引擎V8来分析垃圾数据回收
参考（https://time.geekbang.org/column/article/131233?utm_term=zeusD7HOS&utm_source=app&utm_medium=zhuantiye）

**代际假说**（The Generational Hypothesis）是什么？

The basic idea behind generational garbage collection is called the generational hypothesis, which states that objects created most recently are also most likely to become unreachable soon. 

两个特点：
- 一个是大部分对象在内存中存在的时间很短，就是很多对象一经分配内存，很快就不可访问了
- 第二个是不死的对象，会活得更久

有了代际假说的基础，我们就可以来探讨 V8 是如何实现垃圾回收的了。
在 V8 中会把堆分为**新生代**和**老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。

新生区通常只支持 1～8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。
- **副垃圾回收器，主要负责新生代的垃圾回收。**
- **主垃圾回收器，主要负责老生代的垃圾回收。**

## 垃圾回收器的工作流程

不论什么类型的垃圾回收器，它们都有一套共同的执行流程。
1. 标记活动对象和非活动对象
2. 回收非活动对象的内存空间
3. 内存整理，否则需要分配较大内存时容易出现内存不足

### 副垃圾回收器

新生代中用 Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域

![image](https://github.com/user-attachments/assets/407f05f7-a95d-4a35-8168-341f8fe76434)

新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。

在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。

完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种**角色翻转的操作还能让新生代中的这两块区域无限重复使用下去**。

由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。

也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了**对象晋升策略**，也就是经过两次垃圾回收依然还存活的对象，会被移动到**老生区**中。

### 主垃圾回收器

除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是**对象占用空间大**，另一个是**对象存活时间长**。

由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用**标记 - 清除**（Mark-Sweep）的算法进行垃圾回收的。

1. 标记过程阶段
标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为**活动对象**，没有到达的元素就可以判断为**垃圾数据**。
2. 垃圾清除过程
![image](https://github.com/user-attachments/assets/a7843e8a-b96b-4d9c-bd04-037dfd27564d)

多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——**标记 - 整理**（Mark-Compact）
3. 标记整理过程
![image](https://github.com/user-attachments/assets/05d1539a-c630-412f-852e-a2a41b4066e1)

### 全停顿

由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做**全停顿**（Stop-The-World）。

新生代空间小，全停顿影响不大，老生代空间大，造成卡顿很严重。

为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为**增量标记**（Incremental Marking）算法。

![image](https://github.com/user-attachments/assets/229d2115-8519-4f46-bf4b-9e31b441b019)

使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。
